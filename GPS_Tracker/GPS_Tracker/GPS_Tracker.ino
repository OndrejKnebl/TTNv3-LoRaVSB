/*******************************************************************************
* The Things Network - ABP Feather
*
* This uses ABP (Activation by Personalization), where session keys for
* communication would be assigned/generated by TTN and hard-coded on the device.
*
* Copyright (c) 2015 Thomas Telkamp and Matthijs Kooijman
* Copyright (c) 2018 Terry Moore, MCCI
* Copyright (c) 2018 Brent Rubell, Adafruit Industries
*
* Permission is hereby granted, free of charge, to anyone
* obtaining a copy of this document and accompanying files,
* to do whatever they want with them without any restriction,
* including, but not limited to, copying, modification and redistribution.
* NO WARRANTY OF ANY KIND IS PROVIDED.
* 
* Reference: https://github.com/mcci-catena/arduino-lmic
* 
* Modified for GPS Tracker, 13. 5. 2022
*******************************************************************************/

#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>

#include <TinyGPSPlus.h>
TinyGPSPlus gps;

#include "LowPower.h"                 // Low Power library

// switch tracking / not tracking (for charging only)
int switch_charging = 18;
int switch_tracking = 19;

// LED colors
int green_LED = 22;
int red_LED = 23;

// LED blink
const unsigned BLINK_INTERVAL = 1;   // 1 second
bool green_led_on = false;
bool red_led_on = false;

//--------------------------------------- Here change your keys -------------------------------------------------

static const PROGMEM u1_t NWKSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };   // LoRaWAN NwkSKey, network session key, MSB
static const u1_t PROGMEM APPSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };   // LoRaWAN AppSKey, application session key, MSB
static const u4_t DEVADDR = 0x00000000;                                                                                                       // LoRaWAN end-device address (DevAddr), MSB

//---------------------------------------------------------------------------------------------------------------

uint8_t txBuffer[9];
bool GPS_Error = false;

static osjob_t sendjob;

const lmic_pinmap lmic_pins = {     // Pin mapping for the Adafruit Feather 32u4 LoRa
    .nss = 8,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = 4,
    .dio = {7, 6, LMIC_UNUSED_PIN},
    .rxtx_rx_active = 0,
    .rssi_cal = 8,
    .spi_freq = 1000000,
};

void onEvent (ev_t ev) {
    if(ev == EV_TXCOMPLETE) {
        LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF);         // Sleep time = 8 seconds
        os_setCallback(&sendjob, do_send);      
    }
}


void turnOffLEDs(){
    digitalWrite(red_LED, HIGH);                                // Turn the red LED off by making the voltage HIGH
    digitalWrite(green_LED, HIGH);                              // Turn the green LED off by making the voltage HIGH
    green_led_on = false;
}

void blinkLEDTracking(){
    digitalWrite(red_LED, HIGH);                                // Turn the red LED off by making the voltage HIGH
   
    if (green_led_on){
        digitalWrite(green_LED, HIGH);                          // Turn the green LED off by making the voltage HIGH
    }else{
        digitalWrite(green_LED, LOW);                           // Turn the green LED on by making the voltage LOW
    }
    green_led_on = !green_led_on;
    
    Serial.println(F("Tracking and charging"));
}

void blinkLEDDoingNothing(){
    digitalWrite(green_LED, HIGH);                              // Turn the green LED off by making the voltage HIGH
    digitalWrite(red_LED, HIGH);                                // Turn the red LED on by making the voltage LOW

    if (green_led_on) {
        digitalWrite(green_LED, HIGH);                          // Turn the green LED off by making the voltage HIGH
        digitalWrite(red_LED, LOW);                             // Turn the red LED on by making the voltage LOW
    } else {
        digitalWrite(green_LED, LOW);                           // Turn the green LED on by making the voltage LOW
        digitalWrite(red_LED, HIGH);                            // Turn the red LED off by making the voltage HIGH
    }
    green_led_on = !green_led_on;
    
    Serial.println(F("Not charging and not tracking"));
}

void blinkLEDCharging(){
    digitalWrite(green_LED, HIGH);                              // Turn the green LED off by making the voltage HIGH
    
    if (red_led_on){     
         digitalWrite(red_LED, HIGH);                           // Turn the red LED on by making the voltage LOW
    }else{
         digitalWrite(red_LED, LOW);                            // Turn the red LED on by making the voltage LOW
    }
    red_led_on = !red_led_on;
    
    Serial.println(F("Charging only"));
}



void get_coords(){
    bool newData = false;

    for(unsigned long start = millis(); millis() - start < 1000;){
        while(Serial1.available()){
            if(gps.encode(Serial1.read())){
                newData = true;    
            }
        }
    }

    if(newData && gps.location.isValid() && gps.altitude.isValid() && gps.hdop.isValid() && (gps.location.age() < 1000)){
        GPS_Error = false;
        build_packet();
    }else{
        Serial.println("No GPS or data aren't valid!");
        GPS_Error = true;
    }
}

 
void build_packet(){
    uint32_t latitude = gps.location.lat() * 10000;
    uint32_t longitude = gps.location.lng() * 10000;
    uint16_t altitude = gps.altitude.meters() * 10;
    uint8_t hdop = gps.hdop.value() * 10;

    txBuffer[0] = latitude >> 16;
    txBuffer[1] = latitude >> 8;
    txBuffer[2] = latitude;

    txBuffer[3] = longitude >> 16;
    txBuffer[4] = longitude >> 8;
    txBuffer[5] = longitude;

    txBuffer[6] = altitude >> 8;
    txBuffer[7] = altitude;

    txBuffer[8] = hdop;
}


void do_send(osjob_t* j){
    
    if (digitalRead(switch_tracking) == LOW){                   // Tracking and charging
        blinkLEDTracking();
        
        if(!(LMIC.opmode & OP_TXRXPEND)){                       // Check if there is not a current TX/RX job running
            get_coords();

            if(!GPS_Error){
                turnOffLEDs();
                LMIC_setTxData2(1, (uint8_t*) txBuffer, sizeof(txBuffer)+1, 0);
                Serial.println(F("Packet queued."));
            }else{
                os_setCallback(&sendjob, do_send);
            }
        }else{
            Serial.println(F("OP_TXRXPEND, not sending"));
            os_setCallback(&sendjob, do_send);
        }
    
    }else if(digitalRead(switch_charging) == LOW){              // Charging only
        blinkLEDCharging();    
        LowPower.powerDown(SLEEP_15MS, ADC_OFF, BOD_OFF);       // Sleep time = 15 milliseconds
        blinkLEDCharging();
        LowPower.powerDown(SLEEP_4S, ADC_OFF, BOD_OFF);         // Sleep time = 4 seconds
        os_setCallback(&sendjob, do_send);
        
    }else if((digitalRead(switch_tracking) == HIGH) && (digitalRead(switch_charging) == HIGH)){ // Not charging and not tracking
        blinkLEDDoingNothing();
        os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(BLINK_INTERVAL), do_send);
    
    }else{
        os_setCallback(&sendjob, do_send);
    }
}


void setup() {
    Serial.begin(9600);
    Serial.println(F("Starting"));

    Serial1.begin(9600);

    pinMode(green_LED, OUTPUT);             // Green LED
    pinMode(red_LED, OUTPUT);               // Red LED
    digitalWrite(green_LED, HIGH);          // Turn the green LED off by making the voltage HIGH
    digitalWrite(red_LED, HIGH);            // Turn the red LED off by making the voltage HIGH

    pinMode(switch_charging, INPUT);
    pinMode(switch_tracking, INPUT);
    digitalWrite(switch_charging, HIGH);    // Activate arduino internal pull up
    digitalWrite(switch_tracking, HIGH);    // Activate arduino internal pull up

    os_init();
    LMIC_reset();

    uint8_t appskey[sizeof(APPSKEY)];
    uint8_t nwkskey[sizeof(NWKSKEY)];
    memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));
    memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));
    LMIC_setSession (0x13, DEVADDR, nwkskey, appskey);

    //EU868
    LMIC_setupChannel(0, 868100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(1, 868300000, DR_RANGE_MAP(DR_SF12, DR_SF7B), BAND_CENTI);      // g-band
    LMIC_setupChannel(2, 868500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(3, 867100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(4, 867300000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(5, 867500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(6, 867700000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(7, 867900000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(8, 868800000, DR_RANGE_MAP(DR_FSK,  DR_FSK),  BAND_MILLI);      // g2-band
    
    LMIC_setLinkCheckMode(0);                         // Disable link check validation
    LMIC.dn2Dr = DR_SF9;                              // TTN uses SF9 for its RX2 window.
    LMIC_setDrTxpow(DR_SF7,14);                       // Set data rate and transmit power for uplink
    LMIC_setAdrMode(1); 

    LMIC_setClockError(MAX_CLOCK_ERROR * 1 / 100);

    do_send(&sendjob);                                // Start sendjob
}

void loop() {
    os_runloop_once();
}
